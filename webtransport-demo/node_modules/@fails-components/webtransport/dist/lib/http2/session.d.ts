/// <reference types="node" />
export class Http2WebTransportSession {
    /**
     * @param {{stream?: Http2Stream, ws?: WebSocket, isclient:boolean,
     * createParser:import('../types.js').CreateParserFunction
     * sendWindowOffset: Number,
     * receiveWindowOffset: Number,
     * shouldAutoTuneReceiveWindow: boolean
     * receiveWindowSizeLimit: Number,
     * initialBidirectionalSendStreams: Number,
     * initialBidirectionalReceiveStreams: Number,
     * initialUnidirectionalSendStreams: Number,
     * initialUnidirectionalReceiveStreams: Number}} args
     * */
    constructor({ stream, ws, isclient, createParser, sendWindowOffset, receiveWindowOffset, shouldAutoTuneReceiveWindow, receiveWindowSizeLimit, initialBidirectionalSendStreams, initialBidirectionalReceiveStreams, initialUnidirectionalSendStreams, initialUnidirectionalReceiveStreams }: {
        stream?: Http2Stream;
        ws?: WebSocket;
        isclient: boolean;
        createParser: import('../types.js').CreateParserFunction;
        sendWindowOffset: number;
        receiveWindowOffset: number;
        shouldAutoTuneReceiveWindow: boolean;
        receiveWindowSizeLimit: number;
        initialBidirectionalSendStreams: number;
        initialBidirectionalReceiveStreams: number;
        initialUnidirectionalSendStreams: number;
        initialUnidirectionalReceiveStreams: number;
    });
    jsobj: any;
    stream: import("http2").Http2Stream | undefined;
    ws: WebSocket | undefined;
    capsParser: ParserBase;
    isclient: boolean;
    flowController: FlowController;
    streamIdMngrUni: StreamIdManager;
    streamIdMngrBi: StreamIdManager;
    /** @type {Array<Uint8Array>} */
    datagramsWaiting_: Array<Uint8Array>;
    /** @type {Array<{sendOrder: bigint, sendGroupId: bigint}>} */
    orderUniStreams: {
        sendOrder: bigint;
        sendGroupId: bigint;
    }[];
    /** @type {Array<{sendOrder: bigint, sendGroupId: bigint}>} */
    orderBiStreams: {
        sendOrder: bigint;
        sendGroupId: bigint;
    }[];
    sendInitialParameters(): void;
    drainWrites(): void;
    /**
     * @param {Uint8Array} chunk
     * @return {{ code: "success" | "blocked" | "internalError" | "tooBig", message?: string | undefined; }}
     */
    writeDatagram(chunk: Uint8Array): {
        code: "success" | "blocked" | "internalError" | "tooBig";
        message?: string | undefined;
    };
    trySendingUnidirectionalStreams(): void;
    /**
     * @param {WebTransportSendStreamOptions} opts
     */
    orderUnidiStream({ sendGroup, sendOrder, waitUntilAvailable }: WebTransportSendStreamOptions): boolean;
    trySendingBidirectionalStreams(): void;
    /**
     * @param {WebTransportSendStreamOptions} opts
     */
    orderBidiStream({ sendGroup, sendOrder, waitUntilAvailable }: WebTransportSendStreamOptions): boolean;
    orderSessionStats(): void;
    orderDatagramStats(): void;
    getMaxDatagramSize(): number;
    notifySessionDraining(): void;
    /**
     * @param {{ code: number, reason: string }} arg
     */
    close({ code, reason }: {
        code: number;
        reason: string;
    }): void;
    /**
     * @param {bigint} windowOffset
     */
    sendWindowUpdate(windowOffset: bigint): void;
    /**
     * @param {bigint} pos
     */
    reportBlocked(pos: bigint): void;
    /**
     * @param {bigint} windowOffset
     */
    sendBlocked(windowOffset: bigint): void;
    connected(): boolean;
    /**
     * @param {{ code: number, reason: string }} arg
     */
    closeConnection({ code, reason }: {
        code: number;
        reason: string;
    }): void;
    smoothedRtt(): number;
    /**
     * @returns {boolean}
     */
    canSendMaxStreams(): boolean;
    /**
     * @param {bigint} maxStreams
     * @param {boolean} unidirectional
     */
    sendMaxStreams(maxStreams: bigint, unidirectional: boolean): void;
}
export type Http2Stream = import('http2').Http2Stream;
export type WebTransportSendGroup = import('../dom.js').WebTransportSendGroup;
export type WebTransportSendStreamOptions = import('../dom.js').WebTransportSendStreamOptions;
import { ParserBase } from "./parserbase.js";
import { FlowController } from "./flowcontroller.js";
import { StreamIdManager } from "./streamidmanager.js";
//# sourceMappingURL=session.d.ts.map